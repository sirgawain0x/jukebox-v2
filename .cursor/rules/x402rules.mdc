---
description: x402 is a new open payment protocol developed by Coinbase that enables instant, automatic stablecoin payments directly over HTTP.
alwaysApply: false
---
# Welcome to x402

## Overview

x402 is a new open payment protocol developed by Coinbase that enables instant, automatic stablecoin payments directly over HTTP.

By reviving the [HTTP 402 Payment Required](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status/402) status code, x402 lets services monetize APIs and digital content onchain, allowing clients, both human and machine, to programmatically pay for access without accounts, sessions, or complex authentication.

## Who is x402 for?

* **Sellers:** Service providers who want to monetize their APIs or content. x402 enables direct, programmatic payments from clients with minimal setup.
* **Buyers:** Human developers and AI agents seeking to access paid services without accounts or manual payment flows.

Both sellers and buyers interact directly through HTTP requests, with payment handled transparently through the protocol.

## Use cases

x402 enables a range of use cases, including:

* API services paid per request
* AI agents that autonomously pay for API access
* Paywalls for digital content
* Microservices and tooling monetized via microtransactions
* Proxy services that aggregate and resell API capabilities

## How it works

x402 uses a simple request-response flow with programmatic payments. For a detailed explanation, see [How x402 Works](/x402/core-concepts/how-it-works).

At a high level:

1. The buyer requests a resource from the server (e.g. an API call, see [client/server roles](/x402/core-concepts/client-server))
2. If payment is required, the server responds with a [402 Payment Required](/x402/core-concepts/http-402), including payment instructions
3. The buyer constructs and sends a payment payload
4. The server verifies and settles the payment via the [facilitator](/x402/core-concepts/facilitator). If valid, the server returns the requested resource

## Beyond legacy limitations

x402 is designed for a modern internet economy, solving key limitations of legacy systems:

* **Reduce fees and friction:** Direct onchain payments without intermediaries, high fees, or manual setup.
* **Micropayments & usage-based billing:** Charge per call or feature with simple, programmable pay-as-you-go flows.
* **Machine-to-machine transactions:** Let AI agents pay and access services autonomously with no keys or human input needed.

## Offload your infra

The x402 [Facilitator](/x402/core-concepts/facilitator) handles payment verification and settlement so that sellers don't need to maintain their own blockchain infrastructure.

The Coinbase Developer Platform (CDP) offers a Coinbase-hosted facilitator service that processes fee-free USDC payments on the Base network, offering a streamlined and predictable experience for both buyers and sellers.

Facilitators handle verification and settlement, so sellers do not need to maintain blockchain infrastructure.

CDP's x402 facilitator provides:

* Fee-free USDC payments on the Base network
* Fast, onchain settlement of transactions
* Simplified setup for sellers to start accepting payments

## Facilitator roadmap

CDP's x402 facilitator is designed as a facilitator on top of an open standard, which is not tied to any single provider. Over time, the facilitator will include:

* A discovery layer for buyers (human and agents) to find available services
* Support for additional payment flows (e.g., pay for work done, credit based billing, etc.)
* Optional attestations for sellers to enforce KYC or geographic restrictions
* Support for additional assets and networks

The goal is to make programmatic commerce accessible, permissionless, and developer-friendly.

## What to read next

* [Quickstart for Sellers](/x402/quickstart-for-sellers): Get started with x402 by accepting payments from clients.
* [Quickstart for Buyers](/x402/quickstart-for-buyers): Get started with x402 by paying for services.
* [Network Support](/x402/network-support): See available facilitators and supported networks.
* [How x402 Works](/x402/core-concepts/how-it-works): Understand the complete payment flow.
* [Join our community on Discord](https://discord.gg/invite/cdp): Get help and stay up to date with the latest developments.

# How x402 Works

This page explains the complete payment flow in x402, from initial request to payment settlement.

## Overview

x402 enables programmatic payments over HTTP using a simple request-response flow. When a client requests a paid resource, the server responds with payment requirements, the client submits payment, and the server delivers the resource.

## Payment Flow

<img src="https://mintcdn.com/coinbase-prod/-uP70_EV6KGCA5Hq/x402/images/x402-protocol-flow.png?fit=max&auto=format&n=-uP70_EV6KGCA5Hq&q=85&s=d9dd623f1ff6ccc8092ab994c23c8c59" data-og-width="2984" width="2984" data-og-height="1725" height="1725" data-path="x402/images/x402-protocol-flow.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/coinbase-prod/-uP70_EV6KGCA5Hq/x402/images/x402-protocol-flow.png?w=280&fit=max&auto=format&n=-uP70_EV6KGCA5Hq&q=85&s=fd270b61d4ca043ed17da4ed179b2c66 280w, https://mintcdn.com/coinbase-prod/-uP70_EV6KGCA5Hq/x402/images/x402-protocol-flow.png?w=560&fit=max&auto=format&n=-uP70_EV6KGCA5Hq&q=85&s=1757b276812f2d884d88f18b345928c6 560w, https://mintcdn.com/coinbase-prod/-uP70_EV6KGCA5Hq/x402/images/x402-protocol-flow.png?w=840&fit=max&auto=format&n=-uP70_EV6KGCA5Hq&q=85&s=4d1de430e1d2e19f0a09560106ce885a 840w, https://mintcdn.com/coinbase-prod/-uP70_EV6KGCA5Hq/x402/images/x402-protocol-flow.png?w=1100&fit=max&auto=format&n=-uP70_EV6KGCA5Hq&q=85&s=e8b34ae4370ac3c2b2373d0681383ce7 1100w, https://mintcdn.com/coinbase-prod/-uP70_EV6KGCA5Hq/x402/images/x402-protocol-flow.png?w=1650&fit=max&auto=format&n=-uP70_EV6KGCA5Hq&q=85&s=bd4a806edefdc793bfc4850d92cfb1f4 1650w, https://mintcdn.com/coinbase-prod/-uP70_EV6KGCA5Hq/x402/images/x402-protocol-flow.png?w=2500&fit=max&auto=format&n=-uP70_EV6KGCA5Hq&q=85&s=7fc035915f06c4a4da0c2946fb5a0948 2500w" />

### Step-by-Step Process

1. **Client makes HTTP request** - The [client](/x402/core-concepts/client-server) sends a standard HTTP request to a resource server for a protected endpoint.

2. **Server responds with 402** - The resource server returns an [HTTP 402 Payment Required](/x402/core-concepts/http-402) status code with payment details in the response body.

3. **Client creates payment** - The client examines the payment requirements and creates a payment payload using their [wallet](/x402/core-concepts/wallet) based on the specified scheme.

4. **Client resubmits with payment** - The client sends the same HTTP request again, this time including the `X-PAYMENT` header containing the signed payment payload.

5. **Server verifies payment** - The resource server validates the payment payload either:
   * Locally (if running their own verification)
   * Via a [facilitator](/x402/core-concepts/facilitator) service (recommended)

6. **Facilitator validates** - If using a facilitator, it checks the payment against the scheme and network requirements, returning a verification response.

7. **Server processes request** - If payment is valid, the server fulfills the original request. If invalid, it returns another 402 response.

8. **Payment settlement** - The server initiates blockchain settlement either:
   * Directly by submitting to the blockchain
   * Through the facilitator's `/settle` endpoint

9. **Facilitator submits onchain** - The facilitator broadcasts the transaction to the blockchain based on the payment's network and waits for confirmation.

10. **Settlement confirmation** - Once confirmed onchain, the facilitator returns a payment execution response.

11. **Server delivers resource** - The server returns a 200 OK response with:
    * The requested resource in the response body
    * An `X-PAYMENT-RESPONSE` header containing the settlement details

## Key Components

* **[Client & Server](/x402/core-concepts/client-server)** - The roles and responsibilities of each party
* **[Facilitator](/x402/core-concepts/facilitator)** - Optional service that handles payment verification and settlement
* **[HTTP 402](/x402/core-concepts/http-402)** - How payment requirements are communicated
* **[Networks & Facilitators](/x402/network-support)** - Available networks and facilitator options

## Why This Design?

The x402 protocol is designed to be:

* **Stateless** - No sessions or authentication required
* **HTTP-native** - Works with existing web infrastructure
* **Blockchain-agnostic** - Supports multiple networks through facilitators
* **Developer-friendly** - Simple integration with standard HTTP libraries

## Next Steps

* Ready to accept payments? See [Quickstart for Sellers](/x402/quickstart-for-sellers)
* Want to make payments? See [Quickstart for Buyers](/x402/quickstart-for-buyers)
* Looking for specific networks? Check [Network Support](/x402/network-support)

# HTTP 402

For decades, HTTP 402 Payment Required has been reserved for future use. x402 unlocks it, and [absolves the internet of its original sin](https://economyofbits.substack.com/p/marc-andreessens-original-sin).

## What is HTTP 402?

[HTTP 402](https://datatracker.ietf.org/doc/html/rfc7231#section-6.5.2) is a standard, but rarely used, HTTP response status code indicating that payment is required to access a resource.

In x402, this status code is activated to:

* Inform clients (buyers or agents) that payment is required.
* Communicate the details of the payment, such as amount, currency, and destination address.
* Provide the information necessary to complete the payment programmatically.

## Why x402 Uses HTTP 402

The primary purpose of HTTP 402 is to enable frictionless, API-native payments for accessing web resources, especially for:

* Machine-to-machine (M2M) payments (e.g., AI agents).
* Pay-per-use models such as API calls or paywalled content.
* Micropayments without account creation or traditional payment rails.

Using the 402 status code keeps x402 protocol natively web-compatible and easy to integrate into any HTTP-based service.

## Summary

HTTP 402 is the foundation of the x402 protocol, enabling services to declare payment requirements directly within HTTP responses. It:

* Signals payment is required
* Communicates necessary payment details
* Integrates seamlessly with standard HTTP workflows

## Next Steps

* [How x402 Works](/x402/core-concepts/how-it-works) — See how HTTP 402 fits into the complete payment flow
* [Client & Server](/x402/core-concepts/client-server) — Understand the roles in the x402 protocol
* [Quickstart for Sellers](/x402/quickstart-for-sellers) — Start implementing HTTP 402 responses

# HTTP 402

For decades, HTTP 402 Payment Required has been reserved for future use. x402 unlocks it, and [absolves the internet of its original sin](https://economyofbits.substack.com/p/marc-andreessens-original-sin).

## What is HTTP 402?

[HTTP 402](https://datatracker.ietf.org/doc/html/rfc7231#section-6.5.2) is a standard, but rarely used, HTTP response status code indicating that payment is required to access a resource.

In x402, this status code is activated to:

* Inform clients (buyers or agents) that payment is required.
* Communicate the details of the payment, such as amount, currency, and destination address.
* Provide the information necessary to complete the payment programmatically.

## Why x402 Uses HTTP 402

The primary purpose of HTTP 402 is to enable frictionless, API-native payments for accessing web resources, especially for:

* Machine-to-machine (M2M) payments (e.g., AI agents).
* Pay-per-use models such as API calls or paywalled content.
* Micropayments without account creation or traditional payment rails.

Using the 402 status code keeps x402 protocol natively web-compatible and easy to integrate into any HTTP-based service.

## Summary

HTTP 402 is the foundation of the x402 protocol, enabling services to declare payment requirements directly within HTTP responses. It:

* Signals payment is required
* Communicates necessary payment details
* Integrates seamlessly with standard HTTP workflows

## Next Steps

* [How x402 Works](/x402/core-concepts/how-it-works) — See how HTTP 402 fits into the complete payment flow
* [Client & Server](/x402/core-concepts/client-server) — Understand the roles in the x402 protocol
* [Quickstart for Sellers](/x402/quickstart-for-sellers) — Start implementing HTTP 402 responses

# Facilitator

This page explains the role of the **facilitator** in the x402 protocol.

The facilitator is an optional but recommended service that simplifies the process of verifying and settling payments between clients (buyers) and servers (sellers).

# What is a Facilitator?

The facilitator is a service that:

* Verifies payment payloads submitted by clients.
* Settles payments on the blockchain on behalf of servers.

By using a facilitator, servers do not need to maintain direct blockchain connectivity or implement payment verification logic themselves. This reduces operational complexity and ensures accurate, real-time validation of transactions.

## Facilitator Responsibilities

* **Verify payments:** Confirm that the client's payment payload meets the server's declared payment requirements.
* **Settle payments:** Submit validated payments to the blockchain and monitor for confirmation.
* **Provide responses:** Return verification and settlement results to the server, allowing the server to decide whether to fulfill the client's request.

The facilitator does not hold funds or act as a custodian - it performs verification and execution of onchain transactions based on signed payloads provided by clients.

## Why Use a Facilitator?

Using a facilitator provides:

* **Reduced operational complexity:** Servers do not need to interact directly with blockchain nodes.
* **Protocol consistency:** Standardized verification and settlement flows across services.
* **Faster integration:** Services can start accepting payments with minimal blockchain-specific development.

While it is possible to implement verification and settlement locally, using a facilitator accelerates adoption and ensures correct protocol behavior.

## CDP's Facilitator

Coinbase Developer Platform (CDP) operates a hosted facilitator service.

CDP's x402 facilitator offers:

* **Fee-free USDC payments on Base:** It currently processes transactions without additional fees, allowing sellers to receive 100% of the payment.
* **USDC-only support:** Exclusive support for USDC as the payment asset (for the time being).
* **High performance settlement:** Payments are submitted to the Base network with fast confirmation times and high throughput.

To get started with CDP's facilitator, see the [quickstart for sellers](/x402/quickstart-for-sellers).

Using CDP's facilitator allows sellers to quickly integrate payments without managing blockchain infrastructure, while providing a predictable and low-cost experience for buyers.

## Available Facilitators

For a list of available facilitators and the networks they support, see [Network Support](/x402/network-support).

## How It Works

To understand how facilitators fit into the complete x402 payment flow, see [How x402 Works](/x402/core-concepts/how-it-works).

## Summary

The facilitator acts as an independent verification and settlement layer within the x402 protocol. It helps servers confirm payments and submit transactions onchain without requiring direct blockchain infrastructure.

Coinbase's hosted facilitator simplifies this further by offering a ready-to-use, fee-free environment for USDC payments on Base.

Next, explore:

* [How x402 Works](/x402/core-concepts/how-it-works) — see the complete payment flow
* [Network Support](/x402/network-support) — find available facilitators and networks
* [HTTP 402](/x402/core-concepts/http-402) — understand how payment requirements are communicated

# Wallet

This page explains the role of the **wallet** in the x402 protocol.

In x402, a wallet is both a payment mechanism and a form of unique identity for buyers and sellers. Wallet addresses are used to send, receive, and verify payments, while also serving as identifiers within the protocol.

## Role of the Wallet

### For Buyers

Buyers use wallets to:

* Store USDC
* Sign payment payloads
* Authorize onchain payments programmatically

Wallets enable buyers, including AI agents, to transact without account creation or credential management.

### For Sellers

Sellers use wallets to:

* Receive USDC payments
* Define their payment destination within server configurations

A seller's wallet address is included in the payment requirements provided to buyers.

[CDP's Server Wallet](/server-wallets/v1/concepts/wallets) is our recommended option for programmatic payments and secure key management.

## Summary

* Wallets enable programmatic, permissionless payments in x402.
* Buyers use wallets to pay for services.
* Sellers use wallets to receive payments.
* Wallet addresses also act as unique identifiers within the protocol.

Next, explore:

* [How x402 Works](/x402/core-concepts/how-it-works) — See how wallets fit into the payment flow
* [Client & Server](/x402/core-concepts/client-server) — Understand buyer and seller roles
* [Quickstart for Sellers](/x402/quickstart-for-sellers) — Set up your receiving wallet
* [Quickstart for Buyers](/x402/quickstart-for-buyers) — Configure your payment wallet


# Quickstart for Buyers

This guide walks you through how to use **x402** to interact with services that require payment. By the end of this guide, you will be able to programmatically discover payment requirements, complete a payment, and access a paid resource.

The x402 helper packages for various languages greatly simplify your integration with x402. You'll be able to automatically detect payment challenges, authorize payments onchain, and retry requests — all with minimal code. The packages will automatically trigger the following flow:

1. Makes the initial request (if using Fetch) or intercepts the initial request (if using Axios/HTTPX/Requests)
2. If a 402 response is received, parses the payment requirements
3. Verifies the payment amount is within the allowed maximum
4. Creates a payment header using the provided wallet client
5. Retries the request with the payment header

## Prerequisites

Before you begin, ensure you have:

* A crypto wallet with USDC (any EVM-compatible wallet, e.g., [CDP Wallet](/server-wallets/v1/concepts/wallets), [AgentKit](/agent-kit/welcome))
* [Node.js](https://nodejs.org/en) and npm, or Python and pip
* A service that requires payment via x402

<Info>
  We have pre-configured [examples available in our repo](https://github.com/coinbase/x402/tree/main/examples), including examples for fetch, Axios, and MCP.
</Info>

## 1. Install Dependencies

<Tabs>
  <Tab title="Node.js">
    Install [x402-axios](https://www.npmjs.com/package/x402-axios) or [x402-fetch](https://www.npmjs.com/package/x402-fetch):

    ```bash lines wrap theme={null}
    npm install x402-axios
    # or
    npm install x402-fetch
    ```
  </Tab>

  <Tab title="Python">
    Install the [x402 package](https://pypi.org/project/x402/):

    ```bash lines wrap theme={null}
    pip install x402
    ```
  </Tab>
</Tabs>

## 2. Create a Wallet Client

Create a wallet client using CDP's [Server Wallet](/server-wallets/v1/concepts/wallets) (recommended) or a standalone wallet library ([viem](https://viem.sh/) for EVM on Node.js, [eth-account](https://github.com/ethereum/eth-account) for EVM on Python, or [SolanaKit](https://www.solanakit.com/) for Solana support).

### CDP Server Wallet (Recommended)

First, create an account at [cdp.coinbase.com](https://cdp.coinbase.com/) and get the following API keys from the portal to store as environment variables:

```bash  theme={null}
# store in .env or using the command `export <name>="secret-info"`
CDP_API_KEY_ID=your-api-key-id
CDP_API_KEY_SECRET=your-api-key-secret
CDP_WALLET_SECRET=your-wallet-secret
```

Then, install the required packages:

<CodeGroup>
  ```bash Node.js theme={null}
  npm install @coinbase/cdp-sdk dotenv
  ```

  ```bash Python theme={null}
  pip install cdp python-dotenv
  ```
</CodeGroup>

Finally, instantiate the CDP client as suggested by the [Server Wallet Quickstart](/server-wallets/v2/introduction/quickstart):

<CodeGroup>
  ```typescript Node.js theme={null}
  import { CdpClient } from "@coinbase/cdp-sdk";
  import { toAccount } from "viem/accounts";
  import dotenv from "dotenv";

  dotenv.config()

  const cdp = new CdpClient();
  const cdpAccount = await cdp.evm.createAccount();
  const account = toAccount(cdpAccount);
  ```

  ```python Python theme={null}
  import asyncio
  from cdp import CdpClient
  from dotenv import load_dotenv

  load_dotenv()

  cdp = CdpClient()
  account = await cdp.evm.create_account()
  ```
</CodeGroup>

### Standalone Wallet Libraries

If you prefer to use your own wallet, you can use standalone libraries:

#### EVM

<Tabs>
  <Tab title="Node.js (viem)">
    Install the required package:

    ```bash  theme={null}
    npm install viem
    ```

    Then instantiate the wallet account:

    ```typescript  theme={null}
    import { createWalletClient, http } from "viem";
    import { privateKeyToAccount } from "viem/accounts";
    import { baseSepolia } from "viem/chains";

    // Create a wallet client (using your private key)
    const account = privateKeyToAccount("0xYourPrivateKey"); // we recommend using an environment variable for this
    ```
  </Tab>

  <Tab title="Python (eth-account)">
    Install the required package:

    ```bash  theme={null}
    pip install eth_account
    ```

    Then instantiate the wallet account:

    ```python  theme={null}
    from eth_account import Account

    account = Account.from_key("your_private_key") # we recommend using an environment variable for this
    ```
  </Tab>
</Tabs>

#### Solana (SVM)

Use [SolanaKit](https://www.solanakit.com/) to instantiate a signer:

```typescript  theme={null}
import { createKeyPairSignerFromBytes } from "@solana/kit";
import { base58 } from "@scure/base";

// 64-byte base58 secret key (private + public)
const signer = await createKeyPairSignerFromBytes(
  base58.decode(process.env.SOLANA_PRIVATE_KEY!)
);

```

## 3. Make Paid Requests Automatically

You can automatically handle 402 Payment Required responses and complete payment flows using the x402 helper packages.

<Tabs>
  <Tab title="Node.js">
    You can use either `x402-fetch` or `x402-axios`:

    <Tabs>
      <Tab title="x402-fetch">
        **x402-fetch** extends the native `fetch` API to handle 402 responses and payment headers for you. [Full example here](https://github.com/coinbase/x402/tree/main/examples/typescript/clients/fetch)

        ```typescript  theme={null}
        import { wrapFetchWithPayment, decodeXPaymentResponse } from "x402-fetch";

        const fetchWithPayment = wrapFetchWithPayment(fetch, account);

        fetchWithPayment(url, { //url should be something like https://api.example.com/paid-endpoint
        method: "GET",
        })
        .then(async response => {
            const body = await response.json();
            console.log(body);

            const paymentResponse = decodeXPaymentResponse(response.headers.get("x-payment-response")!);
            console.log(paymentResponse);
        })
        .catch(error => {
            console.error(error.response?.data?.error);
        });
        ```

        **Features:**

        * Automatically handles 402 Payment Required responses
        * Verifies payment and generates payment headers
        * Retries the request with proof of payment
        * Supports all standard fetch options
      </Tab>

      <Tab title="x402-axios">
        **x402-axios** adds a payment interceptor to Axios, so your requests are retried with payment headers automatically. [Full example here](https://github.com/coinbase/x402/tree/main/examples/typescript/clients/axios)

        ```typescript  theme={null}
        import { withPaymentInterceptor, decodeXPaymentResponse } from "x402-axios";
        import axios from "axios";

        // Create an Axios instance with payment handling
        const api = withPaymentInterceptor(
        axios.create({
            baseURL, // e.g. https://api.example.com
        }),
        account,
        );

        api
        .get(endpointPath) // e.g. /paid-endpoint
        .then(response => {
            console.log(response.data);

            const paymentResponse = decodeXPaymentResponse(response.headers["x-payment-response"]);
            console.log(paymentResponse);
        })
        .catch(error => {
            console.error(error.response?.data?.error);
        });
        ```

        **Features:**

        * Automatically handles 402 Payment Required responses
        * Retries requests with payment headers
        * Exposes payment response headers
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Python">
    You can use either `httpx` or `Requests`:

    * **Requests** is a well-established library for **synchronous** HTTP requests. Simple and ideal for straightforward, sequential workflows.
    * **HTTPX** is a modern library that supports both **synchronous** and **asynchronous** HTTP requests. Use if you need high concurrency or async capabilities.

    Both support a **simple** and **extensible** approach. The simple approach (shown below) returns a pre-configured client that handles payments automatically.

    <Tabs>
      <Tab title="HTTPX">
        [Full example here](https://github.com/coinbase/x402/tree/main/examples/python/clients/httpx)

        ```python  theme={null}
        from x402.clients.httpx import x402HttpxClient
        # Other imports...

        # Wallet creation logic ...

        # Create client and make request
        async with x402HttpxClient(account=account, base_url="https://api.example.com") as client:
            response = await client.get("/protected-endpoint")
            print(await response.aread())
        ```
      </Tab>

      <Tab title="Requests">
        [Full example here](https://github.com/coinbase/x402/tree/main/examples/python/clients/requests)

        ```python  theme={null}
        from x402.clients.requests import x402_requests
        # Other imports...

        # Wallet creation logic ...

        # Create session and make request
        session = x402_requests(account)
        response = session.get("https://api.example.com/protected-endpoint")
        print(response.content)
        ```
      </Tab>
    </Tabs>
  </Tab>
</Tabs>

## 4. Discover Available Services (Optional)

Instead of hardcoding endpoints, you can use the x402 Bazaar to dynamically discover available services. This is especially powerful for building autonomous agents that can find and use new capabilities.

See the full example here for [Python](https://github.com/coinbase/x402/tree/main/examples/python/discovery) and [Node.js](https://github.com/coinbase/x402/tree/main/examples/typescript/discovery).

<Tabs>
  <Tab title="Node.js">
    ```typescript  theme={null}
    import { useFacilitator } from "x402/verify";
    import { facilitator } from "@coinbase/x402";

    // Get the list function from the facilitator
    const { list } = useFacilitator(facilitator);

    // Discover all available x402 services
    const services = await list();
    ```
  </Tab>

  <Tab title="Python">
    ```python  theme={null}
    from x402.facilitator import FacilitatorClient
    from cdp.x402 import create_facilitator_config

    # Set up facilitator client
    facilitator_config = create_facilitator_config()
    facilitator = FacilitatorClient(facilitator_config)

    # Discover all available x402 services
    services = await facilitator.list()
    ```
  </Tab>
</Tabs>

<Info>
  Learn more about service discovery in the [x402 Bazaar documentation](/x402/bazaar), including how to filter services, understand their schemas, and build agents that can autonomously discover new capabilities.
</Info>

## 5. Error Handling

Clients will throw errors if:

* The request configuration is missing
* A payment has already been attempted for the request
* There is an error creating the payment header

## Summary

* Install an x402 client package
* Create a wallet client
* Use the provided wrapper/interceptor to make paid API requests
* (Optional) Use the x402 Bazaar to discover services dynamically
* Payment flows are handled automatically for you

## References:

* [x402-fetch npm docs](https://www.npmjs.com/package/x402-fetch)
* [x402-axios npm docs](https://www.npmjs.com/package/x402-axios)
* [x402 PyPi page](https://pypi.org/project/x402/)
* [x402 Bazaar documentation](/x402/bazaar) - Discover available services

For questions or support, join our [Discord](https://discord.gg/invite/cdp).

# Quickstart for Sellers

This guide walks you through integrating with x402 to enable payments for your API or service. By the end, your API will be able to charge buyers and AI agents for access.

<Note>
  This quickstart begins with testnet configuration for safe testing. When you're ready for production, see [Running on Mainnet](#running-on-mainnet) for the simple changes needed to accept real payments.
</Note>

## Prerequisites

Before you begin, ensure you have:

* A crypto wallet to receive funds (any EVM-compatible wallet, e.g., [CDP Wallet](/server-wallets/v1/concepts/wallets))
* (Optional) A [Coinbase Developer Platform](https://cdp.coinbase.com) (CDP) account and API Keys
  * Required for mainnet use until other facilitators go live
* [Node.js](https://nodejs.org/en) and npm, or Python and pip installed
* An existing API or server

<Info>
  We have pre-configured examples available in our repo for both [Node.js](https://github.com/coinbase/x402/tree/main/examples/typescript/servers) and [Python](https://github.com/coinbase/x402/tree/main/examples/python/servers). We also have an [advanced example](https://github.com/coinbase/x402/tree/main/examples/typescript/servers/advanced) that shows how to use the x402 SDKs to build a more complex payment flow.
</Info>

## 1. Install Dependencies

<Tabs>
  <Tab title="Node.js">
    <Tabs>
      <Tab title="Express">
        Install the [x402 Express middleware package](https://www.npmjs.com/package/x402-express):

        ```bash  theme={null}
        npm install x402-express
        npm install @coinbase/x402 # for the mainnet facilitator
        ```
      </Tab>

      <Tab title="Next.js">
        Install the [x402 Next.js middleware package](https://www.npmjs.com/package/x402-next):

        ```bash  theme={null}
        npm install x402-next
        npm install @coinbase/x402 # for the mainnet facilitator
        ```
      </Tab>

      <Tab title="Hono">
        Install the [x402 Hono middleware package](https://www.npmjs.com/package/x402-hono):

        ```bash  theme={null}
        npm install x402-hono
        npm install @coinbase/x402 # for the mainnet facilitator
        ```
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Python">
    Install the [x402 Python package](https://pypi.org/project/x402/):

    ```bash  theme={null}
    pip install x402
    pip install cdp # for the mainnet facilitator
    ```
  </Tab>
</Tabs>

<Note>
  The mainnet facilitator packages (`@coinbase/x402` for Node.js, `cdp` for Python) are only needed for production. For testnet development, you can skip these. See [Running on Mainnet](#running-on-mainnet) for details.
</Note>

## 2. Add Payment Middleware

Integrate the payment middleware into your application. You will need to provide:

* The Facilitator URL or facilitator object. For testing, use `https://x402.org/facilitator` which works on Base Sepolia and Solana Devnet.
  * For mainnet setup, see [Running on Mainnet](#running-on-mainnet)
* The routes you want to protect
* Your receiving wallet address

<Tip>
  The examples below show testnet configuration. When you're ready to accept real payments, refer to [Running on Mainnet](#running-on-mainnet) for the simple changes needed.
</Tip>

<Tabs>
  <Tab title="Node.js">
    <Tabs>
      <Tab title="Express">
        Full example in the repo [here](https://github.com/coinbase/x402/tree/main/examples/typescript/servers/express).

        ```js  theme={null}
        import express from "express";
        import { paymentMiddleware, Network } from "x402-express";
        // import { facilitator } from "@coinbase/x402"; // For mainnet

        const app = express();

        app.use(paymentMiddleware(
          "0xYourAddress", // your receiving wallet address
          {  // Route configurations for protected endpoints
            "GET /weather": {
              // USDC amount in dollars
              price: "$0.001",
              network: "base-sepolia", // for mainnet, see Running on Mainnet section
              // Optional: Add metadata for better discovery in x402 Bazaar
              config: {
                description: "Get current weather data for any location",
                inputSchema: {
                  type: "object",
                  properties: {
                    location: { type: "string", description: "City name" }
                  }
                },
                outputSchema: {
                  type: "object",
                  properties: {
                    weather: { type: "string" },
                    temperature: { type: "number" }
                  }
                }
              }
            },
          },
          {
            url: "https://x402.org/facilitator", // for testnet
          }
        ));

        // Implement your route
        app.get("/weather", (req, res) => {
          res.send({
            report: {
              weather: "sunny",
              temperature: 70,
            },
          });
        });

        app.listen(4021, () => {
          console.log(`Server listening at http://localhost:4021`);
        });
        ```
      </Tab>

      <Tab title="Next.js">
        Full example in the repo [here](https://github.com/coinbase/x402/tree/main/examples/typescript/fullstack/next).

        ```js  theme={null}
        import { paymentMiddleware, Network } from 'x402-next';
        // import { facilitator } from "@coinbase/x402"; // For mainnet

        // Configure the payment middleware
        export const middleware = paymentMiddleware(
          "0xYourAddress", // your receiving wallet address
          {  // Route configurations for protected endpoints
            '/protected': {
              price: '$0.01',
              network: "base-sepolia", // for mainnet, see Running on Mainnet section
              config: {
                description: 'Access to protected content',
                // Optional: Add schemas for better discovery
                inputSchema: {
                  type: "object",
                  properties: {}
                },
                outputSchema: {
                  type: "object",
                  properties: {
                    content: { type: "string" }
                  }
                }
              }
            },
          },
          {
            url: "https://x402.org/facilitator", // for testnet
          }
        );

        // Configure which paths the middleware should run on
        export const config = {
          matcher: [
            '/protected/:path*',
          ]
        };
        ```
      </Tab>

      <Tab title="Hono">
        Full example in the repo [here](https://github.com/coinbase/x402/tree/main/examples/typescript/servers/hono).

        ```js  theme={null}
        import { Hono } from "hono";
        import { serve } from "@hono/node-server";
        import { paymentMiddleware, Network } from "x402-hono";
        // import { facilitator } from "@coinbase/x402"; // For mainnet

        const app = new Hono();

        // Configure the payment middleware
        app.use(paymentMiddleware(
          "0xYourAddress", // your receiving wallet address
          {  // Route configurations for protected endpoints
            "/protected-route": {
              price: "$0.10",
              network: "base-sepolia", // for mainnet, see Running on Mainnet section
              config: {
                description: "Access to premium content",
              }
            }
          },
          {
            url: "https://x402.org/facilitator", // for testnet
          }
        ));

        // Implement your route
        app.get("/protected-route", (c) => {
          return c.json({ message: "This content is behind a paywall" });
        });

        serve({
          fetch: app.fetch,
          port: 3000
        });
        ```
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Python">
    <Tabs>
      <Tab title="FastAPI">
        Full example in the repo [here](https://github.com/coinbase/x402/tree/main/examples/python/servers/fastapi).

        ```python  theme={null}
        import os
        from typing import Any, Dict
        from dotenv import load_dotenv
        from fastapi import FastAPI
        from x402.fastapi.middleware import require_payment
        from x402.types import EIP712Domain, TokenAmount, TokenAsset

        # Load environment variables
        load_dotenv()

        app = FastAPI()

        # Apply payment middleware to specific routes
        app.middleware("http")(
            require_payment(
                path="/weather",
                price="$0.001",
                pay_to_address="0xYourAddress",
                network_id="base-sepolia", # for mainnet, see Running on Mainnet section
                # Optional: Add metadata for better discovery in x402 Bazaar
                description="Get current weather data for any location",
                input_schema={
                    "type": "object",
                    "properties": {
                        "location": {"type": "string", "description": "City name"}
                    }
                },
                output_schema={
                    "type": "object",
                    "properties": {
                        "weather": {"type": "string"},
                        "temperature": {"type": "number"}
                    }
                }
            )
        )

        @app.get("/weather")
        async def get_weather() -> Dict[str, Any]:
            return {
                "report": {
                    "weather": "sunny",
                    "temperature": 70,
                }
            }
        ```
      </Tab>

      <Tab title="Flask">
        Full example in the repo [here](https://github.com/coinbase/x402/tree/main/examples/python/servers/flask).

        ```python  theme={null}
        import os
        from flask import Flask, jsonify
        from dotenv import load_dotenv
        from x402.flask.middleware import PaymentMiddleware
        from x402.types import EIP712Domain, TokenAmount, TokenAsset

        # Load environment variables
        load_dotenv()

        app = Flask(__name__)

        # Initialize payment middleware
        payment_middleware = PaymentMiddleware(app)

        # Apply payment middleware to specific routes
        payment_middleware.add(
            path="/weather",
            price="$0.001",
            pay_to_address="0xYourAddress",
            network="base-sepolia", # for mainnet, see Running on Mainnet section
            # Optional: Add metadata for better discovery in x402 Bazaar
            description="Get current weather data for any location",
            input_schema={
                "type": "object",
                "properties": {
                    "location": {"type": "string", "description": "City name"}
                }
            },
            output_schema={
                "type": "object",
                "properties": {
                    "weather": {"type": "string"},
                    "temperature": {"type": "number"}
                }
            }
        )

        @app.route("/weather")
        def get_weather():
            return jsonify({
                "report": {
                    "weather": "sunny",
                    "temperature": 70,
                }
            })
        ```
      </Tab>
    </Tabs>
  </Tab>
</Tabs>

<Note>
  Ready to accept real payments? See [Running on Mainnet](#running-on-mainnet) for production setup.
</Note>

**Payment Middleware Configuration Interface:**

```typescript  theme={null}
interface PaymentMiddlewareConfig {
  description?: string;               // Description of the payment
  mimeType?: string;                  // MIME type of the resource
  maxTimeoutSeconds?: number;         // Maximum time for payment (default: 60)
  outputSchema?: Record;              // JSON schema for the response
  customPaywallHtml?: string;         // Custom HTML for the paywall
  resource?: string;                  // Resource URL (defaults to request URL)
}
```

When a request is made to these routes without payment, your server will respond with the HTTP 402 Payment Required code and payment instructions.

## 3. Test Your Integration

To verify:

1. Make a request to your endpoint (e.g., `curl http://localhost:3000/your-endpoint`).
2. The server responds with a 402 Payment Required, including payment instructions in the body.
3. Complete the payment using a compatible client, wallet, or automated agent. This typically involves signing a payment payload, which is handled by the client SDK detailed in the [Quickstart for Buyers](/x402/quickstart-for-buyers).
4. Retry the request, this time including the `X-PAYMENT` header containing the cryptographic proof of payment (payment payload).
5. The server verifies the payment via the facilitator and, if valid, returns your actual API response (e.g., `{ "data": "Your paid API response." }`).

## 4. Enhance Discovery with Metadata (Recommended)

When using the CDP facilitator, your endpoints are **automatically listed** in the [x402 Bazaar](/x402/bazaar), our discovery layer that helps buyers and AI agents find services. To improve your visibility and help users understand your API:

<Tip>
  **Include descriptive metadata** in your middleware configuration:

  * **`description`**: Clear explanation of what your endpoint does
  * **`inputSchema`**: JSON schema describing required parameters
  * **`outputSchema`**: JSON schema of your response format

  This metadata helps:

  * AI agents automatically understand how to use your API
  * Developers quickly find services that meet their needs
  * Improve your ranking in discovery results
</Tip>

Example with full metadata:

```javascript  theme={null}
{
  price: "$0.001",
  network: "base",
  config: {
    description: "Get real-time weather data including temperature, conditions, and humidity",
    inputSchema: {
      type: "object",
      properties: {
        location: {
          type: "string",
          description: "City name or coordinates (e.g., 'San Francisco' or '37.7749,-122.4194')"
        },
        units: {
          type: "string",
          enum: ["celsius", "fahrenheit"],
          default: "fahrenheit"
        }
      },
      required: ["location"]
    },
    outputSchema: {
      type: "object",
      properties: {
        temperature: { type: "number", description: "Current temperature" },
        conditions: { type: "string", description: "Weather conditions (sunny, cloudy, rainy, etc.)" },
        humidity: { type: "number", description: "Humidity percentage" }
      }
    }
  }
}
```

Learn more about the discovery layer in the [x402 Bazaar documentation](/x402/bazaar).

## 5. Error Handling

* If you run into trouble, check out the examples in the [repo](https://github.com/coinbase/x402/tree/main/examples) for more context and full code.
* `npm install` the dependencies in each example

## Running on Mainnet

Once you've tested your integration on testnet, you're ready to accept real payments on mainnet. Here's what you need to do:

<Frame>
  <iframe width="560" height="315" src="https://www.youtube.com/embed/Zc_wBlDY2Zc" title="Running x402 on Mainnet" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen className="rounded-lg w-full" />
</Frame>

### 1. Set up CDP API Keys

To use the mainnet facilitator, you'll need a Coinbase Developer Platform account:

1. Sign up at [cdp.coinbase.com](https://cdp.coinbase.com)
2. Create a new project
3. Generate API credentials
4. Set the following environment variables:
   ```bash  theme={null}
   CDP_API_KEY_ID=your-api-key-id
   CDP_API_KEY_SECRET=your-api-key-secret
   ```

### 2. Update Your Code

Replace the testnet configuration with mainnet settings:

<Tabs>
  <Tab title="Node.js">
    ```js  theme={null}
    // Change your imports
    import { facilitator } from "@coinbase/x402";

    // Update the middleware configuration
    app.use(paymentMiddleware(
      "0xYourAddress",
      {
        "GET /weather": {
          price: "$0.001",
          network: "base",
        },
      },
      facilitator // this was previously { url: "https://x402.org/facilitator" }
    ));


    // or for Next.js
    export const middleware = paymentMiddleware(
      "0xYourAddress",
      {
        "GET /weather": {
          price: "$0.001",
          network: "base",
        },
      },
      facilitator // this was previously { url: "https://x402.org/facilitator" }
    ));
    ```
  </Tab>

  <Tab title="Python">
    ```python  theme={null}
    from cdp.x402 import create_facilitator_config

    facilitator_config = create_facilitator_config(
        api_key_id=CDP_API_KEY_ID,
        api_key_secret=CDP_API_KEY_SECRET,
    )

    # Update the middleware configuration (FastAPI)
    app.middleware("http")(
        require_payment(
            path="/weather",
            price="$0.001",
            pay_to_address="0xYourAddress",
            network_id="base", # Changed from "base-sepolia"
            facilitator_config=facilitator_config,
        )
    )

    # Or for Flask:
    payment_middleware.add(
        path="/weather",
        price="$0.001",
        pay_to_address="0xYourAddress",
        network="base", # Changed from "base-sepolia"
        facilitator_config=facilitator_config,
    )
    ```
  </Tab>
</Tabs>

### 3. Update Your Wallet

Make sure your receiving wallet address (`0xYourAddress`) is a real mainnet address where you want to receive USDC payments.

### 4. Test with Real Payments

Before going live:

1. Test with small amounts first
2. Verify payments are arriving in your wallet
3. Monitor the facilitator for any issues

<Warning>
  Mainnet transactions involve real money. Always test thoroughly on testnet first and start with small amounts on mainnet.
</Warning>

## Next Steps

* Looking for something more advanced? Check out the [Advanced Example](https://github.com/coinbase/x402/tree/main/examples/typescript/servers/advanced)
* Get started as a [buyer](/x402/quickstart-for-buyers)

For questions or support, join our [Discord](https://discord.gg/invite/cdp).

## Summary

This quickstart covered:

* Installing the x402 SDK and relevant middleware
* Adding payment middleware to your API and configuring it
* Testing your integration

Your API is now ready to accept crypto payments through x402.

# x402 Bazaar (Discovery Layer)

The x402 Bazaar is the discovery layer for the x402 ecosystem - a machine-readable catalog that helps developers and AI agents find and integrate with x402-compatible API endpoints. Think of it as a search index for payable APIs, enabling the autonomous discovery and consumption of services.

<Note>
  The x402 Bazaar is in early development. While our vision is to build the "Google for agentic endpoints," we're currently more like "Yahoo search" - functional but evolving. Features and APIs may change as we gather feedback and expand capabilities.
</Note>

## Overview

The Bazaar solves a critical problem in the x402 ecosystem: **discoverability**. Without it, x402-compatible endpoints are like hidden stalls in a vast market. The Bazaar provides:

* **For Buyers (API Consumers)**: Programmatically discover available x402-enabled services, understand their capabilities, pricing, and schemas
* **For Sellers (API Providers)**: Automatic visibility for your x402-enabled services to a global audience of developers and AI agents
* **For AI Agents**: Dynamic service discovery without pre-baked integrations - query, find, pay, and use

## How It Works

The Bazaar currently provides a simple `/list` endpoint that returns all x402-compatible services registered with the CDP facilitator. If your API uses the latest version of the CDP facilitator for x402 payments, it's ingested in the bazaar if you make the discoverable flag true in the input schema (see [Quickstart for Sellers](#quickstart-for-sellers)).

### Basic Flow

1. **Discovery**: Clients query the `/list` endpoint to find available services
2. **Selection**: Choose a service based on price, capabilities, and requirements
3. **Execution**: Use x402 to pay for and access the selected service
4. **No Manual Setup**: No API keys, no account creation, just discover and pay

## API Reference

### List Endpoint

Retrieve all available x402-compatible endpoints:

```bash  theme={null}
GET https://api.cdp.coinbase.com/platform/v2/x402/discovery/resources
```

Note: the recommended way to use this endpoint is to use the `useFacilitator` hook as described [below](#quickstart-for-buyers).

#### Response Schema

Each endpoint in the list contains the following fields:

```json  theme={null}
{
      "accepts": [
        {
          "asset": "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913", // ERC-20 token contract address accepted for payment (here, USDC on Base)
          "description": "", // Optional description of the accepted payment
          "extra": {
            "name": "USD Coin", // Human-readable name of the asset
            "version": "2" // Version of the asset, if applicable
          },
          "maxAmountRequired": "200", // Maximum amount (in atomic units, e.g USDC has 6 decimals) required for the service
          "maxTimeoutSeconds": 60, // Maximum time (in seconds) the service will wait for payment before expiring
          "mimeType": "", // Expected MIME type for the response (optional/empty if not specified)
          "network": "base", // network where payment is accepted (e.g., 'base' for Base L2)
          "outputSchema": {
            "input": {
              "method": "GET", // HTTP method to use when calling the resource
              "type": "http" // Type of resource (e.g., 'http' endpoint)
            },
            "output": null // Output schema (null if not specified)
          },
          "payTo": "0xa2477E16dCB42E2AD80f03FE97D7F1a1646cd1c0", // Address to which payment should be sent
          "resource": "https://api.example.com/x402/last_sold", // The actual API endpoint/resource URL
          "scheme": "exact" // Payment scheme (e.g., 'exact' means exact amount required)
        }
      ],
      "lastUpdated": "2025-08-09T01:07:04.005Z", 
      "metadata": {}, // Additional metadata about the service (empty object if none)
      "resource": "https://api.prixe.io/x402/last_sold", // The main resource URL for this service
      "type": "http", 
      "x402Version": 1 // Version of the x402 protocol supported
    },
```

## Quickstart for Buyers

See the full example here for [Python](https://github.com/coinbase/x402/tree/main/examples/python/discovery) and [Node.js](https://github.com/coinbase/x402/tree/main/examples/typescript/discovery).

### Step 1: Discover Available Services

Fetch the list of available x402 services using the facilitator client:

<Tabs>
  <Tab title="Node.js">
    ```typescript  theme={null}
    import { useFacilitator } from "x402/verify";
    import { facilitator } from "@coinbase/x402";

    // Get the list function from the facilitator
    const { list } = useFacilitator(facilitator);

    // Fetch all available services
    const services = await list();

    // NOTE: in an MCP context, you can see the full list then decide which service to use

    // Find services under $0.10
    const usdcAsset = "0x036CbD53842c5426634e7929541eC2318f3dCF7e";
    const maxPrice = 100000;

    const affordableServices = services.items.filter(item => item.accepts.find(paymentRequirements => paymentRequirements.asset == usdcAsset && Number(paymentRequirements.maxAmountRequired) < maxPrice));
    ```
  </Tab>

  <Tab title="Python">
    ```python  theme={null}
    from x402.facilitator import FacilitatorClient, FacilitatorConfig
    from cdp.x402 import create_facilitator_config

    # Set up facilitator client
    facilitator_config = create_facilitator_config()
    facilitator = FacilitatorClient(facilitator_config)

    # Fetch all available services
    services = await facilitator.list()

    # NOTE: in an MCP context, you can see the full list then decide which service to use

    # Find services under $0.10
    usdc_asset = "0x036CbD53842c5426634e7929541eC2318f3dCF7e"
    max_price = 100000

    affordable_services = [
      item
      for item in services.items
      if any(
        payment_req.asset == usdc_asset
        and int(payment_req.max_amount_required) < max_price
        for payment_req in item.accepts
       )
      ]
    ```
  </Tab>
</Tabs>

### Step 2: Call a Discovered Service

Once you've found a suitable service, use an x402 client to call it:

<Tabs>
  <Tab title="Node.js">
    ```typescript  theme={null}
    import { withPaymentInterceptor } from 'x402-axios';
    import axios from 'axios';
    import { privateKeyToAccount } from 'viem/accounts';

    // Set up your payment account
    const account = privateKeyToAccount('0xYourPrivateKey');

    // Select a service from discovery
    const selectedService = affordableServices[0];

    // Create a payment-enabled client for that service
    const client = withPaymentInterceptor(
      axios.create({ baseURL: selectedService.endpoint }), 
      account
    );

    // Select the payment method of your choice
    const selectedPaymentRequirements = selectedService.accepts[0];
    const inputSchema = selectedPaymentRequirements.outputSchema.input;

    // Build the request using the service's schema
    const response = await client.request({
      method: inputSchema.method,
      url: inputSchema.resource,
      params: { location: 'San Francisco' } // Based on inputSchema
    });

    console.log('Response data:', response.data);
    ```
  </Tab>

  <Tab title="Python">
    ```python  theme={null}
    from x402.client import X402Client
    from eth_account import Account

    # Set up your payment account
    account = Account.from_key('0xYourPrivateKey')
    client = X402Client(account)

    # Select a service from discovery
    selected_service = affordable_services[0]

    # Select the payment method of your choice
    selected_payment_requirements = selected_service.accepts[0]
    input_schema = selected_payment_requirements.output_schema.input

    # Make the request
    response = client.request({
        method=input_schema.method,
        url=input_schema.resource,
        params={ "location": "San Francisco" } # Based on input_schema
    })

    print(f"Response data: {response}")
    ```
  </Tab>
</Tabs>

## Quickstart for Sellers

### Automatic Listing with Discoverable Flag

If your API uses the latest version of the CDP facilitator for x402 payments, it's ingested in the bazaar if you make the discoverable flag true in the input schema (see below).

### Adding Metadata

To enhance your listing with descriptions and schemas, include them when setting up your x402 middleware. You should include descriptions for each parameter to make it clear for the agent to call your endpoints:

<Tabs>
  <Tab title="Node.js">
    ```typescript  theme={null}
    // Next.js / Express / Hono
    import { paymentMiddleware, Network } from 'x402-express'; // or x402-next or x402-hono

    app.use(paymentMiddleware({
      routes: {
        "/api/weather": {
          price: "$0.001",
          network: "base",
          config: {
            discoverable: true, // make your endpoint discoverable
            description: "Get current weather data for any location",
            inputSchema: { 
              queryParams: { 
                location: { 
                  type: string, 
                  description: "City name or coordinates", 
                  required: true
                }
              }
            },
            outputSchema: {
              type: "object",
              properties: { 
                temperature: { type: "number" },
                conditions: { type: "string" },
                humidity: { type: "number" }
              }
            }
          }
        }
      }
    }));
    ```
  </Tab>

  <Tab title="Python">
    ```python  theme={null}
    # FastAPI / Flask
    from x402 import require_payment

    app.middleware("http")(
        require_payment(
            path="/weather",
            price="$0.001",
            pay_to_address=WALLET_ADDRESS,
            network="base",
            description="Get current weather data for any location",
            discoverable=true, # make your endpoint discoverable <----
            input_schema={
                "queryParams": {
                    "location": {
                        "type": string,
                        "description": "City name or coordinates",
                        "required": true
                    }
                }
            },
            output_schema={
                "type": "object",
                "properties": {
                    "temperature": {"type": "number"},
                    "conditions": {"type": "string"},
                    "humidity": {"type": "number"}
                }
            }
        )
    )
    ```
  </Tab>
</Tabs>

## Coming Soon

The x402 Bazaar is rapidly evolving, and your feedback helps us prioritize features.

## Support

* **GitHub**: [github.com/coinbase/x402](https://github.com/coinbase/x402)
* **Discord**: [Join #x402 channel](https://discord.com/invite/cdp)
* **Documentation**: [x402 Overview](/x402/welcome)

## FAQ

**Q: How do I get my service listed?**
A: If you're using the CDP facilitator, your service is listed once you include the discoverable flag

**Q: How can I make endpoint calls more accurate?**
A: Include descriptions clearly stating what each parameter does and how to call your endpoint, but do so as succinctly as possible.

**Q: Can I opt out of the Bazaar?**
A: Soon, will be able to manage your listing preferences.

**Q: How does pricing work?**
A: Listing is free. Services set their own prices per API call, paid via x402.

**Q: What networks are supported?**
A: Currently Base (mainnet) with USDC payments.

**Q: Can I list non-x402 services?**
A: No, only x402-compatible endpoints can be listed. See our [seller quickstart](/x402/quickstart-for-sellers) to make your API x402-compatible.

# Building Miniapps with x402

This guide explains how to build miniapps that integrate x402 payments using our official template. The template provides a complete starting point with wallet integration, payment protection, and notifications already configured.

## What are Miniapps?

Miniapps are lightweight applications that run inside Farcaster clients like TBA. Built with [MiniKit](https://onchainkit.xyz/minikit), they provide a native app-like experience while leveraging the social graph and wallet capabilities of Farcaster. By integrating x402, your miniapp can accept instant USDC payments without requiring users to leave the app or manage complex payment flows.

## Why x402 for Miniapps?

x402 is particularly well-suited for miniapps because:

* **Seamless Payments**: Users pay without leaving the miniapp experience
* **No Account Setup**: Works directly with connected wallets
* **Instant Monetization**: Builders can monetize their content or services directly
* **Simple Integration**: Payment protection with just middleware configuration

## Prerequisites

Before starting, ensure you have:

* Node.js 18+ and pnpm v10 installed
* A [Coinbase Developer Platform](https://portal.cdp.coinbase.com) account and API keys (for mainnet)
* A wallet address to receive payments

## Quick Start with the x402 Template

The fastest way to build an x402-powered miniapp is using our official template:

```bash  theme={null}
# Clone the x402 repository
git clone https://github.com/coinbase/x402.git
cd x402/examples/typescript/fullstack/farcaster-miniapp

# Install dependencies
pnpm install

# Build all packages (required for monorepo)
cd ../../
pnpm build
cd fullstack/farcaster-miniapp

# Copy environment variables
cp env.example .env.local

# Configure your environment (see below)
# Then start the development server
pnpm dev
```

## Template Features

The x402 miniapp template includes:

* **Next.js App Router** with TypeScript
* **OnchainKit Integration** for wallet connection
* **x402 Payment Middleware** for protected routes
* **Farcaster Frame SDK** for miniapp detection
* **Notification System** with Redis/Upstash

## Project Structure

```
farcaster-miniapp/
├── app/
│   ├── .well-known/
│   │   └── farcaster.json/    # Dynamic Frame configuration
│   │       └── route.ts
│   ├── api/
│   │   ├── notify/            # Notification proxy endpoint
│   │   ├── protected/         # x402-protected endpoint
│   │   └── webhook/           # Frame webhook handler
│   ├── page.tsx               # Main miniapp interface
│   ├── layout.tsx             # Root layout with providers
│   ├── providers.tsx          # MiniKit and wallet providers
│   └── globals.css            # Global styles
├── lib/
│   └── notification-client.ts # Notification utilities
├── middleware.ts              # x402 payment middleware
└── .env.local                 # Environment configuration
```

## Environment Configuration

Create a `.env.local` file with your configuration:

### Required for x402 Payments

```env  theme={null}
# Your wallet address to receive payments
RESOURCE_WALLET_ADDRESS=0xYourWalletAddress

# Network: "base-sepolia" for testing, "base" for production
NETWORK=base-sepolia

# OnchainKit API key (get from https://portal.cdp.coinbase.com/products/onchainkit)
NEXT_PUBLIC_ONCHAINKIT_API_KEY=your_api_key_here
NEXT_PUBLIC_ONCHAINKIT_PROJECT_NAME=x402 Mini App

# For mainnet only (get from portal.cdp.coinbase.com)
CDP_API_KEY_ID=your_cdp_key_id
CDP_API_KEY_SECRET=your_cdp_key_secret
```

### Frame Configuration (Auto-generated)

Run this command to generate Frame configuration:

```bash  theme={null}
npx create-onchain --manifest
```

This creates the necessary environment variables for:

* Frame metadata and account association
* Notification support via Redis/Upstash
* Mini app detection and integration

## How the Template Works

### 1. Payment Middleware Setup

The `middleware.ts` file configures x402 to protect API routes:

```typescript  theme={null}
import { facilitator } from "@coinbase/x402";
import { paymentMiddleware } from "x402-next";

const payTo = process.env.RESOURCE_WALLET_ADDRESS as Address;
const network = process.env.NETWORK || "base-sepolia";

export const middleware = paymentMiddleware(
  payTo,
  {
    "/api/protected": {
      price: "$0.01",
      network,
      config: {
        description: "Protected route",
      },
    },
  },
  facilitator,
);

export const config = {
  matcher: ["/api/protected"],
  runtime: "nodejs",
};
```

### 2. Protected API Endpoint

The `/api/protected/route.ts` endpoint is automatically protected:

```typescript  theme={null}
import { NextResponse } from "next/server";

export async function GET() {
  // This only executes if payment is verified
  return NextResponse.json({
    success: true,
    message: "Protected action completed successfully",
    timestamp: new Date().toISOString(),
  });
}
```

### 3. Frontend Integration

The main page demonstrates wallet connection and protected API calls:

```tsx  theme={null}
import { wrapFetchWithPayment } from "x402-fetch";
import { getWalletClient } from "wagmi/actions";

// Get wallet client from wagmi
const walletClient = await getWalletClient(config, {
  account: address,
  chainId: chainId,
  connector: connector,
});

// Wrap fetch with x402 payment handling
const fetchWithPayment = wrapFetchWithPayment(fetch, walletClient);

// Call protected endpoint - payment is handled automatically
const response = await fetchWithPayment("/api/protected");
```

### 4. Miniapp Detection

The template detects when running inside Farcaster:

```tsx  theme={null}
import { sdk } from "@farcaster/frame-sdk";

useEffect(() => {
  const initMiniApp = async () => {
    await sdk.actions.ready();
    const isInMiniApp = await sdk.isInMiniApp();
    setIsInMiniApp(isInMiniApp);
  };
  initMiniApp();
}, []);
```

## Customizing the Template

### Adding More Protected Routes

Update `middleware.ts` to add new protected endpoints:

```typescript  theme={null}
export const middleware = paymentMiddleware(
  payTo,
  {
    "/api/protected": {
      price: "$0.01",
      network,
    },
    "/api/premium-content": {
      price: "$1.00",
      network,
      config: {
        description: "Premium content access",
      },
    },
    "/api/exclusive-feature": {
      price: "$5.00",
      network,
      config: {
        description: "Exclusive feature unlock",
      },
    },
  },
  facilitator,
);

export const config = {
  matcher: ["/api/protected", "/api/premium-content", "/api/exclusive-feature"],
};
```

### Implementing Notifications

The template includes notification support via Redis:

```typescript  theme={null}
import { sendFrameNotification } from "@/lib/notification-client";

// Send a notification after successful payment
await sendFrameNotification({
  fid: userFid,
  title: "Payment Successful!",
  body: "You've unlocked premium content",
  notificationDetails: {
    url: "/premium",
    type: "payment_success",
  },
});
```

### Customizing the UI

The template uses Tailwind CSS with a pixel theme. Modify `theme.css` to customize:

```css  theme={null}
/* Custom theme variables */
:root {
  --ockThemePrimary: #4F46E5;
  --ockThemeSecondary: #7C3AED;
  --ockConnectWalletBackground: #FFFFFF;
  /* ... more theme variables ... */
}
```

## Testing Your Miniapp

### Local Development

1. Start your development server:
   ```bash  theme={null}
   pnpm dev
   ```

2. Open [http://localhost:3000](http://localhost:3000) in your browser

3. Test wallet connection and protected API calls

### Testing in Farcaster

1. Use ngrok to expose your local server:
   ```bash  theme={null}
   ngrok http 3000
   ```

2. Update `NEXT_PUBLIC_URL` in `.env.local` with your ngrok URL

3. Cast your frame URL to test in Warpcast

4. Your miniapp will appear with the "Use App" button

## Deployment

### Production Checklist

* Set `NETWORK=base` for mainnet
* Configure CDP API keys for mainnet settlement
* Update `RESOURCE_WALLET_ADDRESS` to your production wallet
* Set proper `NEXT_PUBLIC_URL` for your domain
* Test payment flows thoroughly on testnet first
* Configure Redis for production notifications

## Best Practices

### User Experience

* **Clear Pricing**: Always show prices before requiring payment
* **Loading States**: Show progress during payment processing
* **Error Handling**: Provide clear error messages and recovery options
* **Success Feedback**: Confirm successful payments immediately

### Security

* **Environment Variables**: Never commit sensitive keys
* **Server Validation**: Always verify payments server-side
* **Network Checking**: Ensure users are on the correct network
* **Rate Limiting**: Consider adding rate limits to protected endpoints

## Common Issues and Solutions

### Payment Not Processing

```typescript  theme={null}
// Ensure wallet client is properly configured
if (!walletClient) {
  console.error("Wallet client not available");
  return;
}

// Check network matches configuration
if (chainId !== expectedChainId) {
  console.error("Wrong network");
  return;
}
```

### Miniapp Not Detected

```typescript  theme={null}
// Ensure Frame SDK is initialized
try {
  await sdk.actions.ready();
} catch (error) {
  console.log("Not in miniapp context");
}
```

### 402 Errors Not Handled

```typescript  theme={null}
// Verify middleware matcher includes your route
export const config = {
  matcher: ["/api/your-route"], // Add your route here
};
```

## Next Steps

1. **Explore the Template**: Review all files in the [example repository](https://github.com/coinbase/x402/tree/main/examples/typescript/fullstack/farcaster-miniapp)
2. **Customize for Your Use Case**: Modify the template to fit your specific needs
3. **Add Your Features**: Build on top of the payment foundation
4. **Deploy and Share**: Launch your miniapp to the Farcaster community

## Support

* [x402 Documentation](/x402)
* [OnchainKit Documentation](https://onchainkit.xyz)
* [Farcaster Mini Apps Guide](https://miniapps.farcaster.xyz/)
* [CDP Discord Community](https://discord.gg/cdp)

Start building your monetized Farcaster miniapp today with x402!

# Network & Token Support

This page explains which blockchain networks and tokens are supported by x402, and how to [extend support to additional networks](/x402/network-support#adding-support-for-new-networks).

# Overview

x402 is designed to work across multiple blockchain networks, with different levels of support depending on the facilitator being used. The protocol itself is network-agnostic, but facilitators need to implement network-specific logic for payment verification and settlement.

## Supported Facilitators

Network support in x402 depends on which facilitator you use. Here are the currently available facilitators:

### x402.org Facilitator

* **Supports**: Base Sepolia, Solana Devnet
* **Notes**: Recommended for testing and development. This is the default facilitator in the x402 packages and requires no setup.
* **URL**: [https://x402.org/facilitator](https://x402.org/facilitator)

### CDP's x402 Facilitator

* **Supports**: Base, Base Sepolia, Solana, Solana Devnet
* **Notes**: Production-ready for mainnet payments with KYT/OFAC compliance checks. Can also be used for testing on Base Sepolia. Requires CDP API keys. Uses facilitator object instead of facilitator URL.
* **Requirements**: CDP account and API keys from [cdp.coinbase.com](https://cdp.coinbase.com), see [Quickstart for Sellers: Running on Mainnet](/x402/quickstart-for-sellers#running-on-mainnet) for more details.

### External Facilitators (3rd party)

#### x402.rs Facilitator

* **Supports**: Base Sepolia, Base, XDC Mainnet
* **Notes**: Rust-based facilitator operated by the x402 community.
* **URL**: [https://facilitator.x402.rs](https://facilitator.x402.rs)

### Self-Hosted Facilitators

* **Supports**: Any EVM network
* **Notes**: Run your own facilitator for full control and customization. Supports networks like Avalanche, Polygon, Arbitrum, and other EVM-compatible chains.
* **Setup**: See "Adding Support for New Networks" section below

## Token Support

x402 supports tokens on both EVM and Solana networks:

* **EVM**: Any ERC-20 token that implements the EIP-3009 standard
* **Solana**: All SPL tokens

**Important**: Facilitators support networks, not specific tokens.

### EVM: EIP-3009 Requirement

Tokens must implement the `transferWithAuthorization` function from the EIP-3009 standard. This enables:

* **Gasless transfers**: The facilitator sponsors gas fees
* **Signature-based authorization**: Users sign transfer authorizations off-chain
* **Secure payments**: Transfers are authorized by cryptographic signatures

### Specifying Payment Amounts

When configuring payment requirements, you have two options:

1. **Price String** (e.g., `"$0.01"`) - The system infers USDC as the token
2. **[TokenAmount](https://github.com/coinbase/x402/blob/094dcd2b95b5e13e8673264cc026d080417ee142/typescript/packages/x402/src/types/shared/middleware.ts#L28)** - Specify exact atomic units of any EIP-3009 token

### Using Custom EIP-3009 Tokens (EVM)

To use a custom EIP-3009 token, you need three key pieces of information:

1. **Token Address**: The contract address of your EIP-3009 token
2. **EIP-712 Name**: The token's name for EIP-712 signatures
3. **EIP-712 Version**: The token's version for EIP-712 signatures

#### Finding Token Information on Basescan

You can retrieve the required EIP-712 values from any block explorer:

1. **Name**: Read the `name()` function - [Example on Basescan](https://basescan.org/token/0x833589fcd6edb6e08f4c7c32d4f71b54bda02913#readProxyContract#F16)
2. **Version**: Read the `version()` function - [Example on Basescan](https://basescan.org/token/0x833589fcd6edb6e08f4c7c32d4f71b54bda02913#readProxyContract#F24)

These values are used in the `eip712` nested object when configuring TokenAmount:

```typescript  theme={null}
{
  eip712: {
    name: "USD Coin",    // From name() function
    version: "2"         // From version() function
  }
}
```

### USDC - The Default Token

* **Status**: Supported by default across all networks
* **Why**: On EVM, USDC implements EIP-3009; on Solana, USDC is an SPL token
* **Networks**: Available on Base, Base Sepolia, Solana, and other supported networks

### Why EIP-3009 (EVM)?

The EIP-3009 standard is essential for x402 because it enables:

1. **Gas abstraction**: Buyers don't need native tokens (ETH, MATIC, etc.) for gas
2. **One-step payments**: No separate approval transactions required
3. **Universal facilitator support**: Any EIP-3009 token works with any facilitator

## Quick Reference

| Facilitator     | Networks Supported                        | Production Ready | Requirements    |
| --------------- | ----------------------------------------- | ---------------- | --------------- |
| x402.org        | base-sepolia, solana-devnet               | ❌ Testnet only   | None            |
| CDP Facilitator | base, base-sepolia, solana, solana-devnet | ✅                | CDP API keys    |
| x402.rs         | base-sepolia, base, xdc                   | ✅                | None            |
| Self-hosted     | Any EVM network                           | ✅                | Technical setup |

**Note**: All facilitators support any EIP-3009 compatible token on their supported networks.

## Adding Support for New Networks

There are two ways to add support for new EVM networks in x402:

### Option 1: Contributing to x402 Packages

You can add official network support by submitting a PR to the x402 repository. This makes your network available to all x402 users.

#### Files to Modify

1. **`typescript/packages/x402/src/types/shared/evm/config.ts`**

   Add your network's chain ID and USDC address:

   ```typescript  theme={null}
   // Example: Adding Avalanche networks
   "43113": {  // Avalanche Fuji testnet chain ID
     usdcAddress: "0x5425890298aed601595a70AB815c96711a31Bc65",
     usdcName: "USD Coin",
   },
   "43114": {  // Avalanche mainnet chain ID
     usdcAddress: "0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E",
     usdcName: "USDC",
   },
   ```

2. **`typescript/packages/x402/src/types/shared/network.ts`**

   Add your network to the schema and mappings:

   ```typescript  theme={null}
   // Update the NetworkSchema enum
   export const NetworkSchema = z.enum(["base-sepolia", "base", "avalanche-fuji", "avalanche"]);

   // Add to SupportedEVMNetworks array
   export const SupportedEVMNetworks: Network[] = [
     "base-sepolia",
     "base",
     "avalanche-fuji",
     "avalanche",
   ];

   // Add to EvmNetworkToChainId mapping
   ["avalanche-fuji", 43113],
   ["avalanche", 43114],
   ```

3. **`typescript/packages/x402/src/types/shared/evm/wallet.ts` - Update `getChainFromNetwork` function**

   Add your network to the `getChainFromNetwork` function to map your network string to the viem chain object:

   ```typescript  theme={null}
   import { avalanche, avalancheFuji } from "viem/chains";

   // Add your network to the switch statement in getChainFromNetwork
   case "avalanche":
     return avalanche;
   case "avalanche-fuji":
     return avalancheFuji;
   ```

#### Key Requirements

* **Network key**: Use a consistent network identifier (e.g., `avalanche-fuji`) across all files
* **Viem chain**: Your network must be available in viem/chains or you'll need to define it manually
* **USDC address**: Must be EIP-3009 compatible (has `transferWithAuthorization` function)
* **Chain ID**: Use your network's official chain ID in the config
* **Consistency**: Ensure the network name matches across `NetworkSchema`, `SupportedEVMNetworks`, `EvmNetworkToChainId`, and the `getChainFromNetwork` switch statement

### Option 2: Running Your Own Facilitator

If you need immediate support or want to test before contributing, you can run your own facilitator.

Video Guide: [Adding EVM Chains to x402](https://x.com/jaycoolh/status/1920851551905575164/video/1)

#### Prerequisites

1. Access to an RPC endpoint for your target network
2. A wallet with native tokens for gas sponsorship
3. The x402 facilitator code

## Future Network Support

The x402 ecosystem is actively expanding network support. Planned additions include:

* Additional L2 networks
* Non-EVM chain support (Solana in development)
* Cross-chain payment capabilities

## Getting Help

For help with network integration:

* Join the [x402 Discord community](https://discord.gg/cdp)
* Check the [x402 GitHub repository](https://github.com/coinbase/x402)

## Summary

x402's network support is designed to be extensible while maintaining security and reliability. Whether you're using the default Base Sepolia setup for testing or running your own facilitator for custom networks, the protocol provides flexibility for various use cases.

Key takeaways:

* Base and Base Sepolia have the best out-of-the-box support
* Any EVM network can be supported with a custom facilitator
* Any EIP-3009 token (with `transferWithAuthorization`) works on any facilitator
* Use price strings for USDC or TokenAmount for custom tokens
* Network choice affects gas costs and payment economics

Next, explore:

* [Quickstart for Sellers](/x402/quickstart-for-sellers) — Start accepting payments on supported networks
* [Core Concepts](/x402/core-concepts/how-it-works) — Learn how x402 works under the hood
* [Facilitator](/x402/core-concepts/facilitator) — Understand the role of facilitators
* [MCP Server](/x402/mcp-server) — Set up AI agents to use x402 payments

